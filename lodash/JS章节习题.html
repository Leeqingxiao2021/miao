<script> // 第四章章节练习

  function sum(numbers) {   //求和函数  数组中每一项相加
    var result = 0
    for (var i = 0; i < numbers.length; i++) {
      result += numbers[i]
    }
    return result
  }

  function rang(start, end, step = 1) {      // step = 1 给形参设定默认值        // rang函数 生成一组数字 放在数组中
    var argCount = arguments.length  // 读取输入参数数量
    if (argCount == 1) { //如果输入一个参数 ，把这个参数当作end 设置从1开始
      end = start
      start = 1
    }
    var result = []
    for (var i = start; step > 0 ? i <= end : i >= end; i += step) {
      result.push(i)
    }
    return result
  }

  function reverseArray(array) {  //创建新的倒序数组并返回
    var l = array.length
    var result = Array(l)   // 创建长度为原数组长度的空数组
    for (var i = l - 1; i >= 0; i--) {
      result[l - i - 1] = array[i]
    }
    return result
  }

  function reverseArrayInPlace(array) {// 就地倒序数组  不包括稀疏数组
    var l = array.length - 1
    for (var i = 0; i < l; i++) {
      var num = array[i]
      array[i] = array[l]
      array[l] = num
      l--
    }
    return array
  }


  function deepEqual(a, b) { //深度对比两者是否相同 判断对象属性值是否相同，   面试题
    if (a === b) {         // 两个对象属性与值都相同  两者并不相等  
      return true
    }
    if (a !== a && b !== b) { // 判断a和b 是否都是NaN
      return true
    }

    // 两个都是数组
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false
      } else {
        for (var i = 0; i < a.length; i++) {
          if (!deepEqual(a[i], b[i])) {
            return false
          }
        }
        return true
      }
    }

    // 两个都是对象
    if (!Array.isArray(a) && !Array.isArray(b) && a && b && typeof a === 'object' && typeof b === 'object') {  // 避免 null 的 typeof 为 object 的情况 a && b
      for (var key in a) {
        // a的每个属性都要在b里
        // 一旦不在，就返回false
        if (!(key in b)) {
          return false
        }
      }
      for (var key in b) {
        // b的每个属性都要在a里
        // 一旦不在，就返回false
        if (!(key in a)) {
          return false
        }
      }

      for (var key in a) {
        if (!deepEqual(a[key], b[key])) {
          return false
        }
      }
      return true
    }
    return false
  }


  function arrayToList1(array) {  // 将数组每一项转成 链表结点 再进行拼接

    if (array.length == 0) {   // 如果 数组长度为 0 返回空链表
      return null             // 链表为空 用 null表示
    }

    var nodes = []    //  该方法需要遍历结点  无法使用对象创建链表
    for (var i = 0; i < array.length; i++) {  //将数组每一项 创建为一个结点， 依次填入创建的数组中
      var node = {
        value: array[i],
        next: null,
      }
      nodes.push(node)
    }


    for (var i = 0; i < array.length - 1; i++) { // 数组nodes 的每一项的next 指向 下一结点的对象 注意长度关系
      nodes[i].next = nodes[i + 1]
    }

    return nodes[0] // 如果返回数组nodes， 看到的还是每一结点 在nodes中的排列 
    //每一项的结点中指向后续结点 结果是多个长度递减的链表
    //  返回第0项才可以看到指向关系 单条链表
  }

  function arrayToList2(array) {// 将数组每一项转成 链表  一次生成
    if (array.length == 0) {
      return null
    }

    var head = {          // 创建头节点 0
      value: array[0],
      next: null,
    }

    var prev = head  // 创建变量 进入循环 链接结点 prev变量值会变化 

    for (var i = 1; i < array.length; i++) {  //从1结点开始
      var node = {       // 创建结点
        value: array[i],
        next: null,
      }
      prev.next = node   // 添加下一个结点
      prev = node       //  变量 变为下个结点
    }
    return head      // 返回链表 头结点
  }

  function arrayToList3(array) {// 将数组每一项转成 链表  一次生成  利用虚假结点 

    var dummy = {          // 创建虚假结点 
      value: 0,
      next: null,
    }

    var prev = dummy  // 创建变量 进入循环 链接结点 prev变量值会变化 

    for (var i = 0; i < array.length; i++) {  //从0结点开始
      var node = {       // 创建结点
        value: array[i],
        next: null,
      }
      prev.next = node   // 添加下一个结点 
      prev = node       //  变量 变为下个结点
    }
    return dummy.next      // 返回链表 头结点
  }


  function arrayToList4(array) {// 将数组每一项转成 链表  一次生成  倒序生成链表

    var prev = null // 创建变量 进入循环 链接结点 prev变量值会变化 

    for (var i = array.length - 1; i >= 0; i--) {  //从0结点开始
      var node = {       // 创建结点
        value: array[i],
        next: null,
      }
      node.next = prev   // 添加下一个结点 
      prev = node       //  变量 变为当前结点
    }
    return prev     // 返回链表 头结点
  }

  function arrayToListR(array) {// 将数组每一项转成 链表  一次生成  递归写法 利用slice 空间复杂度为n平方
    if (array.length == 0) {
      return null
    }
    var head = {
      val: array[0],  //slice 后 下标0 就是之前的下一项   递归相当于 倒序生成链表
      next: null
    }
    head.next = arrayToListR(array.slice(1))  // 将数组裁剪第一项，没有改变原数组 ，从下标1开始往后形成一个新数组
    return head      // 返回链表 头结点
  }

  function arrayToListR2(array, start = 0) {// 将数组每一项转成 链表  一次生成  递归写法  加参数  优化版本
    if (start == array.length) {
      return null
    }
    var head = {
      val: array[start],
      next: null,
    }
    head.next = arrayToListR2(array, start + 1)  // 从下标1开始往后
    return head      // 返回链表 头结点
  }

  function listToArray(head) { // 将链表转成数组

    if (head == null) {
      return []
    }

    var result = []
    while (head) {
      result.push(head.val)
      head = head.next
    }
    return result
  }

  function listToArrayR(head) { // 将链表转成数组 递归写法

    if (head == null) {
      return []
    }

    var ary = listToArrayR(head.next)   //倒序拼接 
    return [head.val].concat(ary)  //将当前值的数组 与后续的值形成的数组 拼接
  }

  function prepend(val, head) { //将val 添加到链表head 的开始位置
    return {
      val: val,
      next: head
    }
  }

  function append(val, head) {  //将val 添加到链表head 的末位位置
    var node = {
      val: val,
      next: null,
    }
    if (head == null) {
      return node
    }
    var pver = head
    while (pver.next) {
      pver = pver.next
    }
    pver.next = node
    return head
  }

  function nth(list, n) {  // 返回链表中指定位置的元素
    if (list == null || n < 0) {  //链表为空或者负值位置 返回
      return undefined
    }
    var pver = list // 设置变量指代链表 设置计数器 寻找第n项
    var count = 0
    while (pver && count < n) {   // 当链表结点存在 并且未到指定地点 循环
      count++                     //  计数 小于n就进入下一个结点
      pver = pver.next
    }
    if (pver) {                     // 循环结束后 如果pver存在 返回值，不存在返回undefined
      return pver.val
    } else {
      return undefined
    }
  }

  function nth2(list, n) {   //递归版本  返回链表中指定位置的元素
    if (list == null || n < 0) {
      return undefined
    }
    if (n == 0) {
      return list.val
    }
    return nth2(list.next, n - 1)
  }

  function insert(list, n, val) { // 链表中指定位置n 插入val val的位置变成n 其他结点后移
    var node = {
      val: val,
      next: null,
    }
    if (n == 0) {
      node.next = list
      return node
    }
    var pver = list // 设置变量指代链表 设置计数器 寻找n的前一项 第n-1项 才能使插入项变成第n项
    var count = 0
    while (pver && count < n - 1) {   // 当链表结点存在 并且未到指定地点 循环
      count++                     //  计数 小于n -1就进入下一个结点
      pver = pver.next
    }

    //  var p = pver.next //记录原来第n项的指针
    //  pver.next = node   // 设置指向
    //  node.next = p
    node.next = pver.next
    pver.next = node
    return list
  }
</script>


<script>//第五章习题


  //数组降维
  function flatten1(ary) {                //用reduce和concat方法将二维数组转换成一维数组
    return array.reduce((nums, item) => {   //将结果返回 不需要重新定义变量 初始值为空数组 [] 
      return nums.concat(...item)          //  ...展开运算符可以将item参数 展开一层数组 得到数组里面每个项
    }, [])                                //  concat可以将数组展开一层， 将数组里面的每一项处理 按顺序拼接到另一个数组中 
  }                                         // 直接返回每一次拼接后的，concat 返回新数组

  // 等价写法    ...展开运算符和concat 结合使用可以达到 二维数组变一维效果
  function flatten1(ary) {        //用reduce和concat方法将二维数组转换成一维数组
    return [].concat(...ary)      //  ...展开运算符可以将item参数 展开一层数组 得到数组里面每个项
  }                                 //  concat可以将数组展开一层， 将数组里面的每一项处理 按顺序拼接到另一个数组中 


  function flatten2(ary) {  // 二维数组转一维数组常规写法
    var result = []
    for (var i = 0; i < ary.length; i++) {
      var item = ary[i]
      if (Array.isArray(item)) {
        for (var j = 0; j < item.length; j++) {  // for 循环可以改成一条语句
          result.push(item[j])                  // result.push(...item)    展开运算符可以展开一层数组
        }
      } else {
        result.push(item)
      }
    }
    return result
  }

  function flattenDeep(ary) {   // 多维数组转一维数组  递归
    var result = []
    for (var i = 0; i < ary.length; i++) {
      var item = ary[i]                                 //拿到数组每一项 判断是数组 递归，不是数组按顺序 放到新数组中
      if (Array.isArray(item)) {                        // 是数组递归处理
        item = flattenDeep(item)                        // 将数组里面的数组里面的项放到一维数组中
        for (var j = 0; j < item.length; j++) {          // 递归后返回值是一维数组
          result.push(item[j])
        }
      } else {
        result.push(item)
      }
    }
    return result
  }

  function flattenDeep(ary) {   // 多维数组转一维数组  递归 reduce 写法
    return ary.reduce((result, item) => {
      if (Array.isArray(item)) {
        return result.concat(flattenDeep(item))
      }
      return result.concat(item)
    }, [])
  }


  function flattrnDepth(ary, n = 1) {  // 多维数组减 n维数组  调用已经实现的二维转一维 
    while (n > 0) {
      ary = flatten1(ary)              //问题 n输入为无穷大时会死循环
      n--
    }
    return ary
  }

  function flattrnDepth(ary, n = 1) {  // 多维数组减 n维数组  调用已经实现的多维转一维  递归
    if (n == 0) {
      return ary.slice()     //返回新数组而不是原数组 的原因是 下方返回新数组  为逻辑一致性  所以应该都返回新数组
    }
    return ary.reduce((result, item) => {
      if (Array.isArray(item)) {
        return result.concat(flattrnDepth(item, n - 1))
      }
      return result.concat(item)
    }, [])
  }

  function every(ary, predicate) {  //接收数组 和 一个预测函数，预测函数以数组元素为参数 返回值均为true 为真 其他情况为假
    for (var i = 0; i < ary.length; i++) {
      if (!predicate(ary[i])) {
        return false
      }
    }
    return true
  }

  function some(ary, predicate) {  //接收数组 和 一个预测函数，预测函数以数组元素为参数 返回值均为false为假 其他情况为真
    for (var i = 0; i < ary.length; i++) {
      if (predicate(ary[i])) {
        return true
      }
    }
    return false
  }

  function negate(f) { // 返回原函数的反函数, 原函数返回真时 创建的函数返回假
    return function (...arys) {
      return !f(...arys)
    }
  }
  // predicate         反函数 fp
  //  fp = function(...arys) { return !predicate(...arys)}
  // 运用反函数写every和some  必须先实现一个
  function some(ary, predicate) {
    var fp = function (...arys) {
      return !predicate(...arys)
    }
    return !ary.every(fp)
  }

  // function some(ary, predicate) {
  //   return !ary.every(negate(predicate))
  // }

  //用反函数写法 

  // function every(ary, predicate) {
  //   return !ary.some(negate(predicate))
  // }

  function every(ary, predicate) {
    var fp = function (...arys) {
      return !predicate(...arys)
    }
    return !ary.some(fp)
  }
  // every 等价于  && ，some 等价于 ||
  //  a || b || c == !(!a && !b && !c)  等价转换  摩根定律
  //  a && b && c == !(!a || !b || !c)  等价转换

</script>

<script> //第六章习题

  function Vector(x, y) {  // 向量的构造函数
    this.x = x
    this.y = y
  }

  Vector.prototype.plus = function plus(vector) {  //向量加法运算
    var m = this.x + vector.x
    var n = this.y + vector.y
    return new Vector(m, n)
  }

  Vector.prototype.minus = function minus(vector) { // 向量减法运算
    var m = this.x - vector.x
    var n = this.y - vector.y
    return new Vector(m, n)
  }

  Vector.prototype.getter = function getter() {  // 计数向量到原点距离
    var m = this.x * this.x
    var n = this.y * this.y
    return Math.sqrt(m + n)
  }



  // 虚数的构造函数
  function Complex(real, imag) { // 虚数的构造函数
    this.real = real
    this.imag = imag
  }

    // 虚数的构造函数 如果没有用 new 调用， 避免错误，只要调用该函数，返回该构造函数的实例
    function Complex1(real, imag) {
    //1 if (!(this instanceof Complex)) { //运用new 创建的对象 是构造函数的实例 运用运算符instanceof 判断是否用new 调用
    // return new Complex(real, imag)
    // }

    //2 if (this.__proto__ !== Complex.prototype) { // 实例的原型 是构造函数的prototype属性 不是的情况即为没有用 new
    // return new Complex(real, imag)
    // }

    //3 if (this == window) { // this 是 window 说明 不是用new 调用 而是当函数调用 this 即为window
    // return new Complex(real, imag)
    // }
    this.real = real
    this.imag = imag
  }

  Complex.prototype.plus = function plus(imaginary) { //虚数加法运算
    var real = this.real + imaginary.real
    var imag = this.imag + imaginary.imag
    return new Complex(real, imag)
  }

  Complex.prototype.minus = function minus(imaginary) { //虚数减法运算
    var real = this.real - imaginary.real
    var imag = this.imag - imaginary.imag
    return new Complex(real, imag)
  }

    Complex.prototype.mul = function mul(imaginary) { //虚数乘法运算 537复数乘法 已完成
      var real = this.real * imaginary.real - this.imag * imaginary.imag
      var imag = this.real * imaginary.imag + this.imag * imaginary.real

    return new Complex(real, imag)
  }

    Complex.prototype.div = function div(imaginary) {//虚数除法运算
      var item = new Complex(imaginary.real, -imaginary.imag)
      var fenzhi = this.mul(item)
      var fenmu = imaginary.mul(item)
      return new Complex(fenzhi.real / fenmu.real, fenzhi.imag / fenmu.real)
    }

    Complex.prototype.toString = function () { //将复数按字符显示
      if (this.imag < 0) {
        return "" + this.real + this.imag + "i"
      } else {
        return this.real + "+" + this.imag + "i"
      }
    }

  
  //实现集合 Set 构造函数 实现功能即可 不要求显示形态与浏览器一致 

    function Myset(initial = []) { // 可接一个数组作为参数 设置初始值为空 this._elements=[] // 属性名可以用$ 及 _  用_在这里表示私有属性， 不希望被用户直接读写 
      initial.forEach(it => {
        this.add(it) // 箭头函数没有this 向外面寻找this的值
      });
    }

    Myset.prototype.add = function add(val) { //增加元素
      if (!this.has(val)) {
        this._elements.push(val)
      }
      return this
    }

    Myset.prototype.delete = function (val) { // 删除元素
      var item = this._elements.indexOf(val)
      if (item == -1) {
        return false
      } else {
        this._elements.splice(item, 1)
        return true
      }
    }

    Myset.prototype.has = function has(val) { // 判断集合是否存在某个元素
      return this._elements.includes(val)
    }

    Myset.prototype.clear = function clear() { // 清空集合里的元素
      return this._elements = []
    }

    Object.defineProperty(Myset.prototype, "size", { // 设置size属性 get设置
      get: function () {
        return this._elements.length
      }
    })

    Myset.prototype = {
      add(val) { // add: function(val) {} 的简写 对象的属性是一个普通函数的情况可以简写
        if (!this.has(val)) {
          this._elements.push(val)
        }
        return this
      },
      delete(val) {
        var item = this._elements.indexOf(val)
        if (item == -1) {
          return false
        } else {
          this._elements.splice(item, 1)
          return true
        }
      },
      has(val) {
        return this._elements.includes(val)
      },
      clear() {
        return this._elements = []
      },
      get size() {
        return this._elements.length
      }
    }

    class Myset2 {
      constructor(initial = []) {
        this._elements = []
        initial.forEach(it => {
          this.add(it)
        })
      }
      add(val) {
        if (!this.has(val)) {
          this._elements.push(val)
        }
        return this
      }
      delete(val) {
        var item = this._elements.indexOf(val)
        if (item == -1) {
          return false
        } else {
          this._elements.splice(item, 1)
          return true
        }
      }
      has(val) {
        return this._elements.includes(val)
      }
      clear() {
        return this._elements = []
      }
      get size() {
        return this._elements.length
      }
    }

    // 实现映射 Map 构造函数 实现功能即可 不要求显示形态与浏览器一致
    function Mymap() {
      this._mapKeys = []
      this._mapVals = []
    }

    Mymap.prototype.set = function set(tag, val) { //增加一对映射
      var item = this._mapKeys.indexOf(tag)
      if (item == -1) {
        this._mapKeys.push(tag)
        this._mapVals.push(val)
      } else {
        this._mapVals[item] = val
      }
      return this
    }

    Mymap.prototype.delete = function (tag) { // 删除一对映射
      var item = this._mapKeys.indexOf(tag)
      if (item == -1) {
        return false
      } else {
        this._mapKeys.splice(item, 1)
        this._mapVals.splice(item, 1)
      }
      return this
    }

    Mymap.prototype.get = function get(tag) { // 获取某个映射的值
      var item = this._mapKeys.indexOf(tag)
      if (item !== -1) {
        return this._mapVals[item]
      }
    }

    Mymap.prototype.has = function has(tag) { // 判断某个映射（不是其值）是否存在映射中
      return this._mapKeys.includes(tag)
    }

    Mymap.prototype.clear = function clear() { //清空映射
      this._mapKeys = []
      this._mapVals = []
      return this
    }

    Object.defineProperty(Mymap.prototype, "size", {
      get: function () { return this._mapKeys.length }
    })

    // 用链表实现映射 写在一起的写法 相当于将实例的原型重置 设置为空，并添加属性 为需要的方法
    Mymap.prototype = {
      set(key, val) { // set: function(key,val) {} 的简写 对象的属性是一个普通函数的情况可以简写
        var idx = this._mapKeys.indexOf(key)
        if (idx == -1) {
          this._mapKeys.push(key)
          this._mapVals.push(val)
        } else {
          this.val[idx] = val
        }
        return this
      },
      get(key) {
        var idx = this._mapKeys.indexOf(key)
        if (idx >= 0) {
          return this._mapVals[idx]
        }
      },
      has(key) {
        return this._mapKeys.includes(key)
      },
      delete(key) {
        var idx = this._mapKeys.indexOf(key)
        if (idx == -1) {
          return false
        } else {
          this._mapKeys.splice(idx, 1)
          this._mapVals.splice(idx, 1)
        }
        return this
      },
      clear() {
        this._mapKeys = []
        this._mapVals = []
        return this
      },
      get size() {
        return this._mapKeys.length
      }
    }


    // 用链表实现栈 先进后出
    function Stack(initials = []) { // 链表形式的栈 构造函数 设置默认初始值
      this._head = null // _ 表示私有属性 表示用户不能直接修改
      this._size = 0
      initials.forEach(it => { // 箭头函数没有this 向外面寻找this的值
        this.push(it)
      })
    }

    Stack.prototype.pop = function pop() { // 出栈
      if (this._head) {
        var val = this._head.val
        this._head = this._head.next
        this._size--
        return val
      }
    }

    Stack.prototype.push = function push(val) { //进栈
      var node = {
        val: val,
        next: this._head
      }
      this._head = node
      this._size++
      return this
    }

    Stack.prototype.peek = function peek() { // 返回栈顶元素
      if (this._head) {
        return this._head.val
      }
    }

    Object.defineProperty(Stack.prototype, "size", {
      get: function () { return this._size }
    })

    Stack.prototype = { // 合并写法 改写构造函数属性protorype 对象
      pop() {
        if (this._head) {
          var val = this._head.val
          this._head = this._head.next
          this._size--
          return val
        }
      },
      push(val) {
        var node = {
          val: val,
          next: this._head
        }
        this._head = node
        this._size++
        return this
      },
      peek() {
        if (this._head) {
          return this._head.val
        }
      },
      get size() {
        return this._size
      },
    }

    class Stack2 {

    #head = null
    #size = 0

    constructor(initials = []) {
      initials.forEach(it => {
        this.push(it)
      })
    }

    pop() { // 出栈
      if (this.#head) {
        var val = this.#head.val
        this.#head = this.#head.next
        this.#size--
        return val
      }
    }

    push(val) { //进栈
      var node = {
        val: val,
        next: this.#head
      }
      this.#head = node
      this.#size++
      return this
    }

    peek() { // 返回栈顶元素
      if (this.#head) {
        return this.#head.val
      }
    }
  }

    // 用链表实现队列 先进先出
    function Queue() {// 队列构造函数 只存储 指向头尾结点的指针
      this._head = null // 指向头结点
      this._tail = null // 指向尾结点
      this._size = 0
    }

    Queue.prototype.enqueue = function enqueue(val) { // 进队 放在队列最后
      var node = {
        val: val,
        next: null
      }
      if (!this._head) {
        this._head = node
        this._tail = node
      } else {
        this._tail.next = node
        this._tail = node
      }
      this._size++
      return this
    }

    Queue.prototype.dequeue = function dequeue() { // 出队 队列第一个元素出去
      if (this._head) {
        var val = this._head.val
        this._head = this._head.next
        if (this._head == null) {
          this._tail = null
        }
        this._size--
        return val
      }
    }

    Queue.prototype.peek = function peek() { // 查看队头元素
      if (this._head) {
        return this._head.val
      }
    }

    Object.defineProperty(Queue.prototype, "size", {
      get: function () { return this._size }
    })

    //用链表实现队列 先进先出 写在一起的写法 相当于将实例的原型重置 设置为空，并添加属性 为需要的方法
    Queue.prototype = {
      constructor: Queue,

    enqueue: function enqueue(val) { // 从链表尾结点进队
      var node = { // 创建要进队元素的结点
        val: val,
        next: null
      }
      if (!this._head) {
        this._head = node
        this._tail = node
      } else {
        this._tail.next = node
        this._tail = node
      }
      this._size++
      return this
    },

    dequeue: function dequeue() { //从链表头结点出队
      if (this._head) {
        var val = this._head.val
        this._head = this._head.next
        if (this._head == null) {
          this._tail = null
        }
        this._size--
        return val
      }
    },

    peek: function peek() { // 查看栈顶元素
      if (this._head) {
        return this._head.val
      }
    },

    get size() {
      return this._size
    },
  }

    class Queue2 {
      #head = null
      #tail = null
      #size = 0
      constructor(initial = []) {
        initial.forEach(it => {
          this.enqueue(it) // 箭头函数没有this 找外面的this
        })
      }
      enqueue(val) {
        var node = { // 创建要进队元素的结点
          val: val,
          next: null
        }
        if (!this.#head) {
          this.#head = node
          this.#tail = node
        } else {
          this.#tail.next = node
          this.#tail = node
        }
        this.#size++
        return this
      }
      dequeue() {
        if (this.#head) {
          var val = this.#head.val
          this.#head = this.#head.next
          if (this.#head == null) {
            this.#tail = null
          }
          this.#size--
          return val
        }
      }
      peek() {
        if (this.#head) {
          return this.#head.val
        }
      }
      get size() {
        return this.#size
      }
    }


    /**
    * 使用上方语法实现一个类（一个构造函数的方法等）的时候
    * 会存在一些问题：
    * 代码不是一整块（无法解决 构造函数与构造函数原型属性无法写在一起）
    * 代码的重复有很多：
    * 使用第二种写法 统一重置原型对象 可以避免代码重复
    * 原型上的方法都可以被枚举出来：
    * 对每个原型上的方法及属性使用defineProperty来定义
    * 实现继承的时候比较麻烦：
    * 需要自身重置原型链
    * 复用父类的构造函数时写法比较奇怪：
    * 例如 BasicMap.call(this, xxx, yyy)
    * 构造函数可以不加new调用， 可能返回undefined
    * 在构造函数内添加判断逻辑（this ）解决
    * 静态方法也得一块一块的写：
    * 例 Mymap.xxx = function() {}
    * Mymap.yyy = function() {}
    * 没有私有属性 实现比较 麻烦
    *
    * 上述在书写代码时都有些麻烦
    *
    * 更好方案 写类型的方法
    *
    * class
    *
    */

  // class BasicMap {} 需要继承时提前写好

    // 使用class 实现 Mymap 必须使用new调用 不然会报错
    class Mymap2 {

    // class Mymap2 extends BasicMap {} **extends 继承 构造函数中必须有super（）
    // 继承关系写法 构造函数Mymap2 继承来自构造函数BasicMap，BasicMap需要在继承关系时提前写好
    // Mymap2.prototype.__proto__ === BasicMap.prototype
    // Mymap2.__proto__ === BasicMap 特殊情况

    // 静态方法 函数名前 + 静态 static
    // 即以Mymap2.isMap(val)的形式调用
    // 静态方法挂在构造函数上 不在构造函数的pro属性上 实例访问不到
    static isMap() {

    }
    static fromPairs() {

    }
    // 构造函数 constructor

    // #mapKeys = [] privart class field 语法 类字段
    // #mapVals = [] 私有属性写法 不常用 #标识私有属性
    // 相当于在构造函数{}内（下面的写法）使用this.xxx 调用

    // size = 0; class field 这个 语法有坑
    // count = 0; 在class里声明字段 而不是在构造函数内声明这个用法有问题
    // 这个类型 Mymap2 所有对象都有写在这里的字段

    // 构造函数中不需要外部参数就能确定的属性名和值 写在外面
    // 在外边定义的属性名 访问函数之外的属性值 一同写在外面的属性值
    // 不能被同样写在外面的表达式读取
    // 外面写了 class field 构造函数为空 可以不写构造函数
    constructor(initialPairs = []) {
      this._mapKeys = []// 在外面写带#的属性名之后 这里才可以用那个有#的属性名
      this._mapVals = []
      initialPairs.forEach(pair => {
        var key = pair[0]
        var val = pair[1]
        this.set(key, val) // 增加初始映射对 [ [xx, yy] 、、、] 写法
      })

      // super() 调用父类构造函数 有父类（继承）必须写 没有父类不能写
      // super.xxx() 调用来自父类的方法 这里的this 为父类构造函数 BasicMap
      // this 写在super后面
    }


    // 以下为定义在原型上的方法 class写法 默认不可枚举
    get(key) {
      var idx = this._mapKeys.indexOf(key)
      if (idx >= 0) {
        return this._mapVals[idx]
      }
    }

    set(key, val) {
      var idx = this._mapKeys.indexOf(key)
      if (idx == -1) {
        this._mapKeys.push(key)
        this._mapVals.push(val)
      } else {
        this.val[idx] = val
      }
      return this
    }
    has(key) {
      return this._mapKeys.includes(key)
    }
    delete(key) {
      var idx = this._mapKeys.indexOf(key)
      if (idx == -1) {
        return false
      } else {
        this._mapKeys.splice(idx, 1)
        this._mapVals.splice(idx, 1)
      }
      return this
    }
    clear() {
      this._mapKeys = []
      this._mapVals = []
      return this
    }
    // 以下是定义在原型上的getter/setter/accsser
    get size() {
      return this._mapKeys.length
    }
    set size(val) {
      return ("Ignoring attempt to set size to" + val)
    }
  }

    var id = 0 // 给对象 数组 函数类型添加编号的计数器 全局变量
    class HashTable { // 链式哈希表 通过链表储存数值 通过字符串映射到值

    //构造函数
    constructor() {
      this._maps = Array(32).fill(null) // 每个位置idx 是哈希计算后的下标 存储相同下标属性名的链表 头结点
      this._size = 0
    }

    //以下 是构造函数上的原型属性 实例的原型上的方法

    // 通过映射的key计算出一个整数
    // 期望的目标是对不同的字符串都计算出不同的值 属性名是字符串


    //哈希计算 通过不同的key值获得不同的结果 希望每个key的结果是唯一的
    hashCode(key) { //通过属性名字符串 计算获得存储位置下标
      var hash = 131313131
      var seed = 131
      for (var i = 0; i < key.length; i++) {
        hash = (((hash * seed) >>> 0) + key.charCodeAt(i)) >>> 0
        // 便捷的哈希公式 >>> 0 确保数值过大超出范围时 补码得到负值 确保得到正整数
      }
      return hash % this._maps.length // 得到正整数，模运算数组长度后得到下标
    }

    hashCode2(key) { //判断属性名类型 增加前缀变成字符类型 计算获得存储位置下标
      if (typeof key == "number") { // 三种基本类型转换
        key = 'N-' + key
      } else if (typeof key == "string") {
        key = 'S-' + key
      } else if (typeof key == "boolean") {
        key = 'B-' + key
      } else if (key == null) {
        key = 'NIl-' + key
      } else { // 数组 函数 对象 添加一个属性值objectId 属性值为 id id应为全局变量用于生成字符作为标记
        if ("my_hashtable_objectId" in key) {
          key = key.my_hashtable_objectId
        } else {
          key = key.my_hashtable_objectId = "O-" + String(id++) // 另外三种类型出现一次 编一个号
        } // 除了NaN 无法映射
      }
      var hash = 131313131
      var seed = 131
      for (var i = 0; i < key.length; i++) {
        hash = (((hash * seed) >>> 0) + key.charCodeAt(i)) >>> 0
        // 便捷的哈希公式 >>> 0 确保数值过大超出范围时 补码得到负值 确保得到正整数
      }
      return hash % this._maps.length // 得到正整数，模运算数组长度后得到下标
    }
    set(key, val) { // 增加属性名与属性值
      var idx = this.hashCode(key)
      var p = this._maps[idx]
      while (p) {
        if (p.key === key) {
          p.val = val
          return this
        }
        p = p.next
      }
      this._maps[idx] = {
        val: val,
        key: key,
        next: this._maps[idx]
      }
      this._size++
      if (this._size / this._maps.length > 0.75) { // 扩容条件 达到四分之三 扩容 这个条件可以修改
        this.#toBig()
      }
      return this
    }
    get(key) { // 获取 属性名上的属性值
      var idx = this.hashCode(key)
      var p = this._maps[idx]
      while (p) {
        if (p.key === key) {
          return p.val
        }
        p = p.next
      }
      return undefined
    }
    has(key) { // 是否存在某个属性名
      var idx = this.hashCode(key)
      var p = this._maps[idx]
      while (p) {
        if (p.key === key) {
          return true
        }
        p = p.next
      }
      return false
    }
    delete(key) { // 删除某个属性及其属性值
      var idx = this.hashCode(key)
      var p = this._maps[idx]
      if (p === null) {
        return false
      }
      if (p.key === key) {
        this._maps[idx] = p.next
        this._size--
        if (this._maps.length > 32 && this._size / this._maps.length < 0.2) { // 注意0.2比例的选取， 避免缩容后 增加一位 后立刻需要扩容 长度大于32才需要缩容 
          this.#toSmall()
        } return true
      } while (p.next) {
        if (p.next.key === key) {
          p.next = p.next.next
          this._size--
          if (this._maps.length > 32 && this._size / this._maps.length < 0.2) { this.#toSmall() } return true
        } p = p.next
      }
      return false
    }
    clear() { // 清空哈希表 
      this._maps = Array(32).fill(null)
      this._size = 0
      return this
    }

    //实例上的私有方法
    #toBig() { //扩容 数组长度加倍 
      var prevMaps = this._maps
      this._maps = new Array(this._maps.length * 2).fill(null)
      this._size = 0 //很重要 重置数量 
      for (var list of prevMaps) { // for in 遍历对象属性名 for of 不可遍历对象 可以遍历类数组对象 map set array string 获取属性值 这里的属性值为同idx的链表头节点 
        var p = list
        while (p) {
          var key = p.key
          var val = p.val
          this.set(key, val)
          p = p.next
        }
      }
    }
    #toSmall() { //缩容 
      var prevMaps = this._maps
      this._maps = new Array(this._maps.length / 2).fill(null)
      this._size = 0 //很重要 重置数量 
      for (var list of prevMaps) { 
        var p = list
        while (p) { 
                    var key = p.key
                    var val = p.val
                    this.set(key, val)
                    p = p.next
                  }
                }
              }
            } 

    // 利用已经实现的映射表（哈希表） 创建自己的映射表
    // JS 中的对象就是一个已经实现的映射表 
    var id = 0
    class Mymap3 {  // 了解即可
      constructor() {
        this.map = Object.create(null)
      }
      set(key, val) { 
            if (typeof key == "number") {
              key = 'N' + key
            }
            if (typeof key == "string") {
              key = 'S' + key
            }
            if (typeof key == "boolean") {
              key = 'B' + key
            }
            if (typeof key == "object" || typeof key == "function" || Array.isArray(key)) { //其他三种情况需要定义编号id 按id获得key值 
              if (key._ObjectId) { // 查看输入的类型中是否有 编号属性 
                key = key._ObjectId
              } else {
                key._ObjectId = id++ // 给属性为对象的值添加 编号 
                key = key._ObjectId
              }
            }
            this.map[key] = val
          }
          get(key) {
            return this.map[key]
          }
        }

        class MySet1 { // set 也是哈希 实现的 set集合 是特殊的映射 通过已经实现的mymap实现 myset 
          constructor() {
            this.map = new MyMap()
          }
          add(val) {
            this.map.set(val, '在')
            return this
          }
          delete(val) {
            this.map.delete(val)
          }
          has(val) {
            return this.map.get(val) === '在'
          }
        } 


    //堆 优先队列 大顶堆 （小顶堆）
    class PriorityQueue {
      constructor() {
        this._elements = []
      }
      push(val) { 

    }
    pop() { 

        }
        peek() {

        }
      } 
    </script>

<script>
  //第8章 章节练习
  //8.11.1 重试
  function primitiveMultiply(a, b) {
    if (Math.random() > 0.5) {
      return a * b
    } else {
      throw new MultiplyorUnitFailure()
    }
  }

    function MultiplyorUnitFailure() {

  }

    function multiple(a, b) {

  }

    //上锁的箱子
    var box = {
      locked: true,
      unlock: function () { this.locked = false },
      lock: function () { this.locked = true },
      _content: [],
      get content() {
        if (this.locked) throw new Error("Locked!");
        return this._content;
      }
    }

    function withBoxUnlocked(f) {

  }
</script>
